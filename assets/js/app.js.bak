/**
 * !ntellibot OSINT Dashboard - Optimized Version
 * Fetches real-time data from Netlify Functions API
 */

// API Configuration
const API_BASE = '';

// Fallback data
const FallbackData = window.FallbackData || { 
    news: [], 
    crypto: [], 
    forex: [], 
    metals: [], 
    events: [], 
    signals: [
        {
            id: 'sig-1',
            title: 'Ongoing geopolitical tensions in Eastern Europe region',
            summary: 'International diplomatic efforts continue as regional stability remains a concern.',
            source: 'International OSINT',
            type: 'military',
            confidence: 0.8,
            pubDate: new Date().toISOString(),
            region: 'Europe',
            tags: ['conflict', 'military']
        },
        {
            id: 'sig-2',
            title: 'Middle East diplomatic discussions ongoing',
            summary: 'Regional leaders engage in talks to address ongoing concerns.',
            source: 'Regional OSINT',
            type: 'political',
            confidence: 0.7,
            pubDate: new Date().toISOString(),
            region: 'Middle East',
            tags: ['diplomacy', 'political']
        },
        {
            id: 'sig-3',
            title: 'Maritime activity reported in South China Sea',
            summary: 'Naval movements being monitored in international waters.',
            source: 'Maritime OSINT',
            type: 'strategic',
            confidence: 0.75,
            pubDate: new Date().toISOString(),
            region: 'Asia',
            tags: ['naval', 'strategic']
        },
        {
            id: 'sig-4',
            title: 'Cyber activity detected targeting financial sector',
            summary: 'Digital infrastructure monitoring shows elevated activity patterns.',
            source: 'Cyber OSINT',
            type: 'security',
            confidence: 0.7,
            pubDate: new Date().toISOString(),
            region: 'Global',
            tags: ['cyber', 'security']
        },
        {
            id: 'sig-5',
            title: 'Energy market fluctuations in European region',
            summary: 'Trading patterns indicate supply chain adjustments.',
            source: 'Energy OSINT',
            type: 'economic',
            confidence: 0.65,
            pubDate: new Date().toISOString(),
            region: 'Europe',
            tags: ['energy', 'economic']
        }
    ], 
    predictions: [] 
};

// Application State
const appState = {
    currentPage: 'dashboard',
    data: {
        news: [],
        crypto: [],
        forex: [],
        metals: [],
        events: [],
        signals: [],
        predictions: []
    },
    map: null,
    markers: [],
    aircraftMarkers: [],
    selectedEvent: null,
    lastUpdated: null,
    refreshInterval: null,
    dataLoaded: {
        news: false,
        crypto: false,
        forex: false,
        events: false
    }
};

// Source filtering for OSINT relevance
const IrrelevantPatterns = [
    // University/College sources
    /university|college|campus|student|faculty|alumni|graduation|freshmen|undergraduate|graduate school/i,
    // Sports scores
    /espn|sports score|match result|game|championship|tournament|athletic/i,
    // Entertainment
    /celebrity|hollywood|box office|movie premiere|album release|concert/i,
    // Local/community
    /city council.*meeting|police blotter|obituary|anniversary|wedding|birthday/i,
    // Commerce
    /amazon sale|black friday|cyber monday|price drop|discount|clearance/i
];

// Keywords that make content relevant (override filters)
const RelevanceKeywords = [
    'military','war','conflict','terror','attack','bomb','shoot','killed','death',
    'police','government','president','minister','election','diplomat','sanction',
    'border','troop','nato','russia','china','ukraine','iran','israel','north korea',
    'nuclear','missile','drone','navy','army','air force','marine','coast guard',
    'crime','violence','protest','riot','demonstration','crisis','emergency'
];

function isRelevantEvent(event) {
    const title = event.title || '';
    const source = event.source || '';
    const summary = event.summary || '';
    const content = `${title} ${source} ${summary}`;
    
    // Check if content contains any relevance keywords
    const hasRelevanceKeyword = RelevanceKeywords.some(keyword => 
        content.toLowerCase().includes(keyword.toLowerCase())
    );
    
    if (hasRelevanceKeyword) return true;
    
    // Check if source is blocked
    const isBlocked = IrrelevantPatterns.some(pattern => 
        pattern.test(source) || pattern.test(title)
    );
    
    return !isBlocked;
}

function filterRelevantEvents(events) {
    return events.filter(event => isRelevantEvent(event));
}

// Utility Functions
function formatRelativeTime(dateString) {
    if (!dateString) return 'Just now';
    const date = new Date(dateString);
    const now = new Date();
    const diffMs = now - date;
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);
    const diffDays = Math.floor(diffMs / 86400000);

    if (diffMins < 1) return 'Just now';
    if (diffMins < 60) return `${diffMins}m ago`;
    if (diffHours < 24) return `${diffHours}h ago`;
    if (diffDays < 7) return `${diffDays}d ago`;
    return date.toLocaleDateString();
}

function formatDateTime(dateString) {
    if (!dateString) return 'Unknown';
    return new Date(dateString).toLocaleString('en-US', {
        year: 'numeric',
        month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        timeZone: 'UTC'
    });
}

function formatNumber(num) {
    if (num === undefined || num === null) return 'N/A';
    if (num >= 1000000000000) return (num / 1000000000000).toFixed(2) + 'T';
    if (num >= 1000000000) return (num / 1000000000).toFixed(2) + 'B';
    if (num >= 1000000) return (num / 1000000).toFixed(2) + 'M';
    if (num >= 1000) return (num / 1000).toFixed(2) + 'K';
    return num.toLocaleString();
}

function getSeverityColor(severity) {
    const colors = {
        critical: '#ef4444',
        high: '#f97316',
        medium: '#f59e0b',
        low: '#84cc16',
        info: '#06b6d4'
    };
    return colors[severity] || colors.info;
}

function getSeverityClass(severity) {
    return severity || 'info';
}

// API Functions
async function fetchFromAPI(endpoint) {
    try {
        const response = await fetch(`${API_BASE}${endpoint}`);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        return await response.json();
    } catch (error) {
        console.error(`Error fetching ${endpoint}:`, error);
        return null;
    }
}

async function fetchWithTimeout(endpoint, timeout = 15000) {
    try {
        const controller = new AbortController();
        const id = setTimeout(() => controller.abort(), timeout);
        
        const response = await fetch(`${API_BASE}${endpoint}`, {
            signal: controller.signal
        });
        clearTimeout(id);
        
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        return await response.json();
    } catch (error) {
        console.warn(`Failed to fetch ${endpoint}:`, error.message);
        return null;
    }
}

async function fetchAllData() {
    showLoading();
    
    // Core data endpoints (fetch sequentially for better reliability)
    const coreEndpoints = [
        { key: 'news', endpoint: '/.netlify/functions/news', timeout: 20000 },
        { key: 'events', endpoint: '/.netlify/functions/events', timeout: 20000 },
        { key: 'crypto', endpoint: '/.netlify/functions/crypto', timeout: 15000 },
        { key: 'forex', endpoint: '/.netlify/functions/forex', timeout: 15000 }
    ];
    
    // Optional endpoints (fetch in background)
    const optionalEndpoints = [
        { key: 'signals', endpoint: '/.netlify/functions/signals', timeout: 15000 },
        { key: 'predictions', endpoint: '/.netlify/functions/predictions', timeout: 15000 }
    ];
    
    try {
        // Fetch core data sequentially
        for (const { key, endpoint, timeout } of coreEndpoints) {
            try {
                const data = await fetchWithTimeout(endpoint, timeout);
                if (data) {
                    appState.data[key] = data[key] || data.news || data.events || [];
                    appState.dataLoaded[key] = true;
                }
            } catch (error) {
                console.warn(`Failed to fetch ${key}:`, error.message);
                appState.data[key] = FallbackData[key] || [];
            }
        }
        
        // Fetch optional data in parallel (don't wait)
        optionalEndpoints.forEach(({ key, endpoint, timeout }) => {
            fetchWithTimeout(endpoint, timeout).then(data => {
                if (data && data[key] && data[key].length > 0) {
                    appState.data[key] = data[key] || data.signals || data.predictions || [];
                } else {
                    // Use fallback data if API returns empty or fails
                    appState.data[key] = FallbackData[key] || [];
                }
            }).catch(() => {
                // Use fallback data on error
                appState.data[key] = FallbackData[key] || [];
            });
        });
        
        appState.lastUpdated = new Date().toISOString();
        
        // Update UI
        renderAll();
        updateLastUpdatedTime();
        showToast('Data Updated', 'Dashboard data refreshed successfully', 'success');
    } catch (error) {
        console.error('Error fetching all data:', error);
        showToast('Using Cached Data', 'Some data may be unavailable', 'warning');
    } finally {
        hideLoading();
    }
}

// Map Functions
function initializeMap(containerId, options = {}) {
    const container = document.getElementById(containerId);
    if (!container) return null;

    const map = new maplibregl.Map({
        container: container,
        style: {
            version: 8,
            sources: {
                'dark-tiles': {
                    type: 'raster',
                    tiles: [
                        'https://a.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png',
                        'https://b.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png',
                        'https://c.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png'
                    ],
                    tileSize: 256,
                    attribution: '© OpenStreetMap contributors © CARTO'
                },
                'military-activity': {
                    type: 'geojson',
                    data: {
                        type: 'FeatureCollection',
                        features: []
                    }
                }
            },
            layers: [
                {
                    id: 'dark-layer',
                    type: 'raster',
                    source: 'dark-tiles'
                },
                // Heatmap layer for activity density
                {
                    id: 'military-heat',
                    type: 'heatmap',
                    source: 'military-activity',
                    paint: {
                        'heatmap-weight': [
                            'interpolate', ['linear'], ['get', 'intensity'],
                            0, 0,
                            1, 1
                        ],
                        'heatmap-intensity': [
                            'interpolate', ['linear'], ['zoom'],
                            0, 1,
                            9, 3
                        ],
                        'heatmap-color': [
                            'interpolate', ['linear'], ['heatmap-density'],
                            0, 'rgba(33,102,172,0)',
                            0.2, 'rgb(103,169,207)',
                            0.4, 'rgb(209,229,240)',
                            0.6, 'rgb(253,219,199)',
                            0.8, 'rgb(239,138,98)',
                            1, 'rgb(178,24,43)'
                        ],
                        'heatmap-radius': [
                            'interpolate', ['linear'], ['zoom'],
                            0, 20,
                            9, 40
                        ],
                        'heatmap-opacity': 0.7
                    }
                },
                // Point layer for interaction
                {
                    id: 'military-point',
                    type: 'circle',
                    source: 'military-activity',
                    paint: {
                        'circle-radius': [
                            'interpolate', ['linear'], ['zoom'],
                            1, 4,
                            5, 8,
                            10, 12
                        ],
                        'circle-color': [
                            'match', ['get', 'category'],
                            'army', '#ef4444',
                            'navy', '#3b82f6',
                            'air-force', '#f59e0b',
                            'combined-ops', '#10b981',
                            '#6b7280'
                        ],
                        'circle-stroke-width': 2,
                        'circle-stroke-color': '#ffffff',
                        'circle-stroke-opacity': 0.8,
                        'circle-opacity': 0.9
                    }
                }
            ]
        },
        center: options.center || [25, 30],
        zoom: options.zoom || 3
    });

    map.addControl(new maplibregl.NavigationControl(), 'top-right');
    map.addControl(new maplibregl.ScaleControl(), 'bottom-left');
    
    // Add click handler for activity popups
    map.on('click', 'military-point', (e) => {
        if (e.features && e.features.length > 0) {
            const props = e.features[0].properties;
            const coordinates = e.features[0].geometry.coordinates.slice();
            
            const colors = {
                army: '#ef4444',
                navy: '#3b82f6',
                'air-force': '#f59e0b',
                'combined-ops': '#10b981',
                unknown: '#6b7280'
            };
            const color = colors[props.category] || colors.unknown;
            
            new maplibregl.Popup()
                .setLngLat(coordinates)
                .setHTML(`
                    <div style="padding: 10px; min-width: 150px; font-family: monospace; background: #1a1a1a; color: #fff; border-radius: 4px;">
                        <div style="font-weight: bold; font-size: 14px; color: ${color}; margin-bottom: 8px;">
                            ${props.title || 'Military Activity'}
                        </div>
                        <div style="font-size: 12px;">
                            <div><strong>Location:</strong> ${props.location || 'Unknown'}</div>
                            <div><strong>Category:</strong> ${(props.category || 'unknown').replace('-', ' ').toUpperCase()}</div>
                            <div><strong>Country:</strong> ${props.country || 'Unknown'}</div>
                            <div><strong>Intensity:</strong> ${((props.intensity || 0) * 100).toFixed(0)}%</div>
                            <div><strong>Time:</strong> ${props.time || 'Last 24h'}</div>
                        </div>
                    </div>
                `)
                .addTo(map);
        }
    });
    
    // Change cursor on hover
    map.on('mouseenter', 'military-point', () => {
        map.getCanvas().style.cursor = 'pointer';
    });
    map.on('mouseleave', 'military-point', () => {
        map.getCanvas().style.cursor = '';
    });
    
    return map;
}

// Military Activity Heatmap Generator
const MilitaryTracker = {
    interval: null,
    lastUpdate: null,
    
    generateActivityData() {
        const now = new Date();
        this.lastUpdate = now;
        
        const activityZones = [
            // Europe
            { name: 'Eastern Ukraine', lat: 48.5, lng: 35.5, intensity: 1.0, category: 'army', country: 'Ukraine/Russia' },
            { name: 'Black Sea', lat: 44.0, lng: 34.0, intensity: 0.9, category: 'navy', country: 'Russia/Ukraine' },
            { name: 'Baltic Region', lat: 55.0, lng: 24.0, intensity: 0.7, category: 'air-force', country: 'NATO' },
            { name: 'Poland Border', lat: 52.0, lng: 23.0, intensity: 0.8, category: 'army', country: 'NATO' },
            { name: 'Joint Exercises - Europe', lat: 50.0, lng: 16.0, intensity: 0.6, category: 'combined-ops', country: 'NATO' },
            // Middle East
            { name: 'Syria', lat: 35.0, lng: 38.0, intensity: 0.8, category: 'army', country: 'Multiple' },
            { name: 'Red Sea', lat: 15.0, lng: 42.0, intensity: 0.9, category: 'navy', country: 'US/Iran' },
            { name: 'Persian Gulf', lat: 27.0, lng: 52.0, intensity: 0.85, category: 'navy', country: 'Iran/US' },
            { name: 'Israel/Gaza', lat: 31.5, lng: 34.5, intensity: 0.95, category: 'army', country: 'Israel' },
            { name: 'Joint Exercises - ME', lat: 28.0, lng: 35.0, intensity: 0.5, category: 'combined-ops', country: 'US/Allies' },
            // Asia Pacific
            { name: 'South China Sea', lat: 15.0, lng: 115.0, intensity: 0.9, category: 'navy', country: 'China/US' },
            { name: 'Taiwan Strait', lat: 24.0, lng: 119.0, intensity: 0.85, category: 'navy', country: 'China/Taiwan' },
            { name: 'Korean Peninsula', lat: 38.0, lng: 127.0, intensity: 0.9, category: 'army', country: 'North Korea/South Korea' },
            { name: 'Joint Exercises - Asia', lat: 20.0, lng: 130.0, intensity: 0.55, category: 'combined-ops', country: 'US/Allies' },
            // Africa
            { name: 'Sudan', lat: 13.0, lng: 30.0, intensity: 0.8, category: 'army', country: 'Sudan' },
            { name: 'Somalia', lat: 5.0, lng: 46.0, intensity: 0.75, category: 'navy', country: 'International' },
            // Americas
            { name: 'Caribbean', lat: 15.0, lng: -75.0, intensity: 0.5, category: 'navy', country: 'US' },
            { name: 'Joint Exercises - Americas', lat: 25.0, lng: -80.0, intensity: 0.4, category: 'combined-ops', country: 'US/Partners' },
            // Additional
            { name: 'Mediterranean', lat: 35.0, lng: 18.0, intensity: 0.7, category: 'navy', country: 'NATO' },
            { name: 'Arctic', lat: 75.0, lng: 40.0, intensity: 0.6, category: 'navy', country: 'Russia/NATO' },
        ];
        
        const features = [];
        activityZones.forEach(zone => {
            const numPoints = Math.floor(zone.intensity * 10) + 5;
            for (let i = 0; i < numPoints; i++) {
                const latOffset = (Math.random() - 0.5) * (zone.intensity * 3);
                const lngOffset = (Math.random() - 0.5) * (zone.intensity * 5);
                features.push({
                    type: 'Feature',
                    geometry: { type: 'Point', coordinates: [zone.lng + lngOffset, zone.lat + latOffset] },
                    properties: {
                        title: zone.category.charAt(0).toUpperCase() + zone.category.slice(1).replace('-', ' ') + ' Activity',
                        location: zone.name,
                        country: zone.country,
                        category: zone.category,
                        intensity: zone.intensity * (0.5 + Math.random() * 0.5),
                        time: 'Last 24h',
                        timestamp: now.toISOString()
                    }
                });
            }
        });
        return { type: 'FeatureCollection', features };
    },
    
    updateHeatmap(map) {
        if (!map) return;
        const source = map.getSource('military-activity');
        if (!source) return;
        const data = this.generateActivityData();
        source.setData(data);
        this.updateStats(data.features.length);
        // Update sidebar with activity data
        if (typeof renderMapEventsSidebar === 'function') {
            renderMapEventsSidebar(data.features);
        }
        console.log('Heatmap updated:', { points: data.features.length, lastUpdate: this.lastUpdate });
    },
    
    updateStats(count) {
        const totalEl = document.getElementById('totalAircraft');
        if (totalEl) totalEl.textContent = count;
        
        // Calculate counts by category from activity data
        const categoryCounts = { army: 0, navy: 0, 'air-force': 0, 'combined-ops': 0 };
        const data = this.generateActivityData();
        data.features.forEach(feature => {
            const cat = feature.properties?.category;
            if (categoryCounts.hasOwnProperty(cat)) {
                categoryCounts[cat]++;
            }
        });
        
        const fighterEl = document.getElementById('fighterCount');
        const helicopterEl = document.getElementById('helicopterCount');
        const droneEl = document.getElementById('droneCount');
        const cargoEl = document.getElementById('cargoCount');
        
        // Map categories to stat elements: army -> Army Activity, navy -> Navy Activity, air-force -> Air Activity, combined-ops -> Combined Ops
        if (fighterEl) fighterEl.textContent = categoryCounts.army || Math.floor(count * 0.25);
        if (helicopterEl) helicopterEl.textContent = categoryCounts.navy || Math.floor(count * 0.25);
        if (droneEl) droneEl.textContent = categoryCounts['air-force'] || Math.floor(count * 0.25);
        if (cargoEl) cargoEl.textContent = categoryCounts['combined-ops'] || Math.floor(count * 0.25);
    },
    
    startTracking(map) {
        this.updateHeatmap(map);
        this.interval = setInterval(() => this.updateHeatmap(map), 5 * 60 * 1000);
        console.log('Military activity heatmap started');
    },
    
    stopTracking() {
        if (this.interval) {
            clearInterval(this.interval);
            this.interval = null;
        }
    }
};

// Keep addEventMarkers for compatibility but make it empty
function addEventMarkers(map, events) {
    // Replaced by MilitaryTracker
}

// Rendering Functions
function renderAll() {
    renderStats();
    renderRecentEvents();
    renderFeeds();
    renderMarkets();
    renderSourceStatus();
    renderSourcesTable();
    renderMapEventsSidebar();
    renderSignals();
    renderPredictions();
    populateSourceFilters();
}

function renderStats() {
    // Filter out irrelevant sources first
    const events = filterRelevantEvents(appState.data.events || []);
    const now = new Date();
    
    // Calculate last 24 hours events
    const last24h = events.filter(e => {
        const eventDate = new Date(e.pubDate || e.timestamps?.published_at);
        return (now - eventDate) < 24 * 60 * 60 * 1000;
    });
    
    // Count high/critical severity
    const highCritical = last24h.filter(e => 
        (e.severity || e.metadata?.severity) === 'high' || 
        (e.severity || e.metadata?.severity) === 'critical'
    );
    
    // Count unique countries
    const countries = new Set(
        last24h
            .filter(e => e.location?.country || e.location?.country_code)
            .map(e => e.location.country || e.location.country_code)
    );
    
    // Update DOM elements
    const totalEventsEl = document.getElementById('totalEvents');
    const highSeverityEl = document.getElementById('highSeverityCount');
    const countriesAffectedEl = document.getElementById('countriesAffected');
    
    if (totalEventsEl) totalEventsEl.textContent = last24h.length || events.length;
    
    if (highSeverityEl) {
        highSeverityEl.textContent = highCritical.length;
    }
    
    if (countriesAffectedEl) {
        countriesAffectedEl.textContent = countries.size || '0';
    }
    
    // Also update data attributes for debugging
    console.log('Stats:', {
        total24h: last24h.length,
        highCritical: highCritical.length,
        countries: countries.size,
        totalEvents: events.length
    });
}

function renderRecentEvents() {
    const container = document.getElementById('recentEventsList');
    if (!container) return;

    let events = appState.data.events || [];
    
    // Filter out irrelevant sources
    events = filterRelevantEvents(events);
    
    if (events.length === 0) {
        container.innerHTML = '<div style="padding: 1rem; text-align: center; color: #71717a;">No relevant events found...</div>';
        return;
    }

    const sortedEvents = [...events]
        .sort((a, b) => new Date(b.pubDate || b.timestamps?.published_at) - new Date(a.pubDate || a.timestamps?.published_at))
        .slice(0, 10);

    container.innerHTML = sortedEvents.map(event => `
        <div class="event-item" data-event-id="${event.id}">
            <div class="event-severity-indicator ${getSeverityClass(event.severity || event.metadata?.severity)}"></div>
            <div class="event-content">
                <div class="event-title">${event.title || 'No Title'}</div>
                <div class="event-meta">
                    <span class="event-source">${event.source || 'Unknown'}</span>
                    <span>•</span>
                    <span>${formatRelativeTime(event.pubDate || event.timestamps?.published_at)}</span>
                    ${event.location?.place_name ? `<span>•</span><span>${event.location.place_name}</span>` : ''}
                </div>
            </div>
        </div>
    `).join('');

    // Add click handlers
    container.querySelectorAll('.event-item').forEach(item => {
        item.addEventListener('click', () => {
            const event = appState.data.events.find(e => e.id === item.dataset.eventId);
            if (event) openEventModal(event);
        });
    });
}

// Track selected filters for multi-select functionality
const feedSelectedSources = new Set();
const signalSelectedTypes = new Set();

function populateSourceFilters() {
    populateFeedSourceCheckboxes();
    populateSignalTypeCheckboxes();
    setupFilterEventListeners();
}

function populateFeedSourceCheckboxes() {
    const container = document.getElementById('feedSourceCheckboxes');
    if (!container) return;
    
    const feeds = appState.data.news || [];
    const sources = [...new Set(feeds.map(feed => feed.source).filter(Boolean))].sort();
    
    console.log('Populating feed checkboxes:', { feedsCount: feeds.length, sourcesCount: sources.length });
    
    if (sources.length === 0) {
        container.innerHTML = '<div style="padding: 0.5rem; color: var(--color-text-muted); font-size: 0.875rem;">Loading sources...</div>';
        return;
    }
    
    // Reset and select all by default
    feedSelectedSources.clear();
    
    container.innerHTML = sources.map(source => `
        <div class="checkbox-item">
            <input type="checkbox" id="feed-source-${CSS.escape(source)}" value="${source}" checked>
            <label for="feed-source-${CSS.escape(source)}" title="${source}">${source}</label>
        </div>
    `).join('');
    
    // Add all sources to selected set
    sources.forEach(s => feedSelectedSources.add(s));
    
    // Add change listeners to checkboxes (track selection but don't filter yet)
    container.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
        checkbox.addEventListener('change', () => {
            const value = checkbox.value;
            if (checkbox.checked) {
                feedSelectedSources.add(value);
            } else {
                feedSelectedSources.delete(value);
            }
        });
    });
    
    // Initial render
    renderFeeds();
}

function populateSignalTypeCheckboxes() {
    const container = document.getElementById('signalTypeCheckboxes');
    if (!container) return;
    
    const signalTypes = [
        { value: 'military', label: 'Military' },
        { value: 'political', label: 'Political' },
        { value: 'economic', label: 'Economic' },
        { value: 'security', label: 'Security' },
        { value: 'strategic', label: 'Strategic' },
        { value: 'general', label: 'General' }
    ];
    
    // Select all by default
    signalSelectedTypes.clear();
    signalTypes.forEach(t => signalSelectedTypes.add(t.value));
    
    container.innerHTML = signalTypes.map(type => `
        <div class="checkbox-item">
            <input type="checkbox" id="signal-type-${type.value}" value="${type.value}" checked>
            <label for="signal-type-${type.value}">${type.label}</label>
        </div>
    `).join('');
    
    // Add change listeners - only update selection, don't apply filter yet
    container.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
        checkbox.addEventListener('change', () => {
            const value = checkbox.value;
            if (checkbox.checked) {
                signalSelectedTypes.add(value);
            } else {
                signalSelectedTypes.delete(value);
            }
        });
    });
}

function setupFilterEventListeners() {
    // Feed select all / clear all / apply filter
    const feedSelectAll = document.getElementById('feedSelectAll');
    const feedClearAll = document.getElementById('feedClearAll');
    const feedApplyFilter = document.getElementById('feedApplyFilter');
    
    if (feedSelectAll) {
        feedSelectAll.addEventListener('click', () => {
            const checkboxes = document.querySelectorAll('#feedSourceCheckboxes input[type="checkbox"]');
            checkboxes.forEach(cb => {
                cb.checked = true;
                feedSelectedSources.add(cb.value);
            });
            renderFeeds();
            showToast('Filter Updated', 'All sources selected', 'info');
        });
    }
    
    if (feedClearAll) {
        feedClearAll.addEventListener('click', () => {
            const checkboxes = document.querySelectorAll('#feedSourceCheckboxes input[type="checkbox"]');
            checkboxes.forEach(cb => {
                cb.checked = false;
                feedSelectedSources.delete(cb.value);
            });
            renderFeeds();
            showToast('Filter Updated', 'All sources cleared', 'info');
        });
    }
    
    if (feedApplyFilter) {
        feedApplyFilter.addEventListener('click', () => {
            renderFeeds();
            const selectedCount = feedSelectedSources.size;
            showToast('Filter Applied', `${selectedCount} sources selected`, 'success');
        });
    }
    
    // Signal type select all / clear all / apply filter
    const typeSelectAll = document.getElementById('typeSelectAll');
    const typeClearAll = document.getElementById('typeClearAll');
    const typeApplyFilter = document.getElementById('typeApplyFilter');
    
    if (typeSelectAll) {
        typeSelectAll.addEventListener('click', () => {
            const checkboxes = document.querySelectorAll('#signalTypeCheckboxes input[type="checkbox"]');
            checkboxes.forEach(cb => {
                cb.checked = true;
                signalSelectedTypes.add(cb.value);
            });
            renderSignals();
            showToast('Filter Updated', 'All types selected', 'info');
        });
    }
    
    if (typeClearAll) {
        typeClearAll.addEventListener('click', () => {
            const checkboxes = document.querySelectorAll('#signalTypeCheckboxes input[type="checkbox"]');
            checkboxes.forEach(cb => {
                cb.checked = false;
                signalSelectedTypes.delete(cb.value);
            });
            renderSignals();
            showToast('Filter Updated', 'All types cleared', 'info');
        });
    }
    
    if (typeApplyFilter) {
        typeApplyFilter.addEventListener('click', () => {
            renderSignals();
            const selectedCount = signalSelectedTypes.size;
            showToast('Filter Applied', `${selectedCount} types selected`, 'success');
        });
    }
}

function renderFeeds() {
    const container = document.getElementById('feedsGrid');
    if (!container) return;

    const feeds = appState.data.news || [];
    
    console.log('Rendering feeds:', { feedsCount: feeds.length, selectedSourcesCount: feedSelectedSources.size });
    
    // If no feeds loaded yet, show loading message
    if (feeds.length === 0) {
        container.innerHTML = '<div style="padding: 2rem; text-align: center; color: #71717a;">Loading news feeds...</div>';
        return;
    }
    
    // Filter by selected sources (multi-select)
    const selectedSources = Array.from(feedSelectedSources);
    const filteredFeeds = selectedSources.length === 0 || selectedSources.length === feeds.length
        ? feeds 
        : feeds.filter(feed => feed.source && feedSelectedSources.has(feed.source));
    
    // Sort by date posted (newest first)
    filteredFeeds.sort((a, b) => new Date(b.pubDate || b.timestamps?.published_at) - new Date(a.pubDate || a.timestamps?.published_at));
    
    if (filteredFeeds.length === 0) {
        container.innerHTML = '<div style="padding: 2rem; text-align: center; color: #71717a;">No news feeds available for selected sources...</div>';
        return;
    }

    container.innerHTML = filteredFeeds.slice(0, 12).map(feed => `
        <div class="feed-card">
            <div class="feed-card-header">
                <div class="feed-source-icon">${(feed.source || 'NN').substring(0, 2).toUpperCase()}</div>
                <div class="feed-source-info">
                    <div class="feed-source-name">${feed.source || 'News Source'}</div>
                    <div class="feed-pub-date">${formatRelativeTime(feed.pubDate)}</div>
                </div>
            </div>
            <h4 class="feed-card-title">${feed.title}</h4>
            <p class="feed-card-summary">${(feed.summary || '').substring(0, 150)}...</p>
            <div class="feed-card-footer">
                <div class="feed-tags">
                    ${(feed.categories || []).slice(0, 3).map(tag => `<span class="feed-tag">${tag}</span>`).join('')}
                </div>
                <a href="${feed.link || '#'}" target="_blank" rel="noopener" class="read-more-btn">Read More</a>
            </div>
        </div>
    `).join('');
}

function renderMarkets() {
    const container = document.getElementById('marketsGrid');
    if (!container) return;

    const crypto = appState.data.crypto || [];
    const forex = appState.data.forex || [];
    const metals = appState.data.metals || [];
    const forexHistory = appState.data.forex?.historical || {};
    const cryptoHistory = appState.data.crypto?.historical || {};
    let html = '';

    // Render Crypto with charts (if available)
    if (crypto && crypto.length > 0) {
        html += crypto.slice(0, 8).map((coin, index) => {
            const history = cryptoHistory[coin.id] || [];
            const chartSvg = renderSparklineChart(history, coin.change24h >= 0);
            const priceChangeClass = (coin.change24h || 0) >= 0 ? 'positive' : 'negative';
            
            return `
            <div class="market-card" data-coin="${coin.id}">
                <div class="market-header">
                    <div class="market-name-icon">
                        <span class="market-icon">${coin.symbol.substring(0, 1)}</span>
                        <div class="market-name-info">
                            <span class="market-name">${coin.name}</span>
                            <span class="market-symbol">${coin.symbol}</span>
                        </div>
                    </div>
                    <span class="market-rank">#${coin.rank || '-'}</span>
                </div>
                <div class="market-price-section">
                    <div class="market-price">$${coin.price?.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2}) || 'N/A'}</div>
                    <div class="market-change ${priceChangeClass}">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="${(coin.change24h || 0) >= 0 ? '23 6 13.5 15.5 8.5 10.5 1 18' : '23 18 13.5 8.5 8.5 13.5 1 6'}"></polyline>
                        </svg>
                        <span>${(coin.change24h || 0) >= 0 ? '+' : ''}${(coin.change24h || 0).toFixed(2)}% (24h)</span>
                    </div>
                    ${coin.change7d !== undefined ? `
                    <div class="market-change-7d ${(coin.change7d || 0) >= 0 ? 'positive' : 'negative'}">
                        <span>7d: ${(coin.change7d || 0) >= 0 ? '+' : ''}${(coin.change7d || 0).toFixed(2)}%</span>
                    </div>
                    ` : ''}
                </div>
                ${history.length > 0 ? `
                <div class="market-chart-container">
                    ${chartSvg}
                    <span class="chart-label">7 Day Price History</span>
                </div>
                ` : ''}
                <div class="market-stats">
                    <div class="market-stat">
                        <div class="market-stat-value">$${formatNumber(coin.marketCap)}</div>
                        <div class="market-stat-label">Market Cap</div>
                    </div>
                    <div class="market-stat">
                        <div class="market-stat-value">$${formatNumber(coin.volume24h)}</div>
                        <div class="market-stat-label">24h Volume</div>
                    </div>
                </div>
            </div>
            `;
        }).join('');
    }

    // Render Forex with charts (if available)
    if (forex && forex.length > 0) {
        html += forex.slice(0, 6).map(currency => {
            const history = forexHistory[currency.currency] || [];
            const chartSvg = renderSparklineChart(history, true);
            
            return `
            <div class="market-card forex-card" data-currency="${currency.currency}">
                <div class="market-header">
                    <div class="market-name-icon">
                        <span class="market-icon forex">${currency.currency.substring(0, 1)}</span>
                        <div class="market-name-info">
                            <span class="market-name">${getCurrencyName(currency.currency)}</span>
                            <span class="market-symbol">${currency.pair || 'USD/XXX'}</span>
                        </div>
                    </div>
                    <span class="live-indicator-mini">
                        <span class="pulse-small"></span>
                        LIVE
                    </span>
                </div>
                <div class="market-price-section">
                    <div class="market-price">${(currency.rate || 0).toFixed(4)}</div>
                    <div class="market-change neutral">
                        <span>Frankfurter API</span>
                    </div>
                </div>
                ${history.length > 0 ? `
                <div class="market-chart-container">
                    ${chartSvg}
                    <span class="chart-label">7 Day Rate History (USD Base)</span>
                </div>
                ` : '<div class="market-chart-placeholder"><span>Chart loading...</span></div>'}
                <div class="market-meta">
                    <span class="last-updated">Updated: ${formatRelativeTime(appState.data.forex?.lastUpdated)}</span>
                </div>
            </div>
            `;
        }).join('');
    }

    if (html === '') {
        html = '<div style="padding: 2rem; text-align: center; color: #71717a;">Loading market data...</div>';
    }

    container.innerHTML = html;
}

function getCurrencyName(code) {
    const names = {
        'EUR': 'Euro',
        'GBP': 'British Pound',
        'JPY': 'Japanese Yen',
        'CNY': 'Chinese Yuan',
        'INR': 'Indian Rupee',
        'RUB': 'Russian Ruble',
        'CHF': 'Swiss Franc',
        'CAD': 'Canadian Dollar',
        'AUD': 'Australian Dollar',
        'KRW': 'South Korean Won',
        'SGD': 'Singapore Dollar',
        'BRL': 'Brazilian Real'
    };
    return names[code] || code;
}

function renderSparklineChart(data, isPositive = true) {
    if (!data || data.length === 0) {
        return '<svg class="sparkline-chart" viewBox="0 0 200 60"><text x="100" y="35" text-anchor="middle" fill="#71717a" font-size="12">No data</text></svg>';
    }
    
    const prices = data.map(d => d.price || d.rate);
    const minPrice = Math.min(...prices);
    const maxPrice = Math.max(...prices);
    const range = maxPrice - minPrice || 1;
    
    const width = 200;
    const height = 60;
    const padding = 5;
    
    const points = data.map((d, i) => {
        const x = (i / (data.length - 1)) * (width - padding * 2) + padding;
        const y = height - ((d.price || d.rate - minPrice) / range) * (height - padding * 2) - padding;
        return `${x},${y}`;
    }).join(' ');
    
    const lineColor = isPositive ? '#22c55e' : '#ef4444';
    const fillColor = isPositive ? 'rgba(34, 197, 94, 0.1)' : 'rgba(239, 68, 68, 0.1)';
    
    // Calculate start and end points for area fill
    const startX = padding;
    const endX = width - padding;
    const startY = height - padding;
    const firstY = height - ((prices[0] - minPrice) / range) * (height - padding * 2) - padding;
    const lastY = height - ((prices[prices.length - 1] - minPrice) / range) * (height - padding * 2) - padding;
    
    return `
    <svg class="sparkline-chart" viewBox="0 0 ${width} ${height}" preserveAspectRatio="none">
        <defs>
            <linearGradient id="chartGradient-${isPositive ? 'pos' : 'neg'}" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" style="stop-color:${lineColor};stop-opacity:0.3" />
                <stop offset="100%" style="stop-color:${lineColor};stop-opacity:0" />
            </linearGradient>
        </defs>
        <path d="M ${startX} ${startY} L ${startX} ${firstY} L ${points.split(' ').map(p => 'L ' + p).join(' ').substring(2)} L ${endX} ${lastY} Z" fill="url(#chartGradient-${isPositive ? 'pos' : 'neg'})" />
        <polyline points="${points}" fill="none" stroke="${lineColor}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
        <circle cx="${endX}" cy="${lastY}" r="3" fill="${lineColor}" />
    </svg>
    `;
}

function renderSourceStatus() {
    const container = document.getElementById('sourceStatusGrid');
    if (!container) return;

    const sources = [
        { name: 'News Feeds', status: appState.data.news.length > 0 ? 'online' : 'offline' },
        { name: 'Crypto API', status: appState.data.crypto.length > 0 ? 'online' : 'offline' },
        { name: 'Forex API', status: appState.data.forex.length > 0 ? 'online' : 'offline' },
        { name: 'Events API', status: appState.data.events.length > 0 ? 'online' : 'offline' },
        { name: 'GDELT Events', status: appState.data.events.length > 0 ? 'online' : 'offline' }
    ];

    container.innerHTML = sources.map(source => `
        <div class="source-status-item">
            <div class="source-status-dot ${source.status}"></div>
            <div class="source-status-info">
                <div class="source-status-name">${source.name}</div>
                <div class="source-status-time">${source.status === 'online' ? 'Active' : 'Connecting...'}</div>
            </div>
        </div>
    `).join('');
}

function renderSourcesTable() {
    const container = document.getElementById('sourcesTableBody');
    if (!container) return;

    const sources = [
        // Major International News
        { name: 'BBC World', type: 'RSS Feed', url: 'http://feeds.bbci.co.uk/news/world/rss.xml', status: appState.data.news.length > 0 ? 'online' : 'offline' },
        { name: 'Reuters World', type: 'RSS Feed', url: 'http://feeds.reuters.com/reuters/worldNews', status: appState.data.news.length > 0 ? 'online' : 'offline' },
        { name: 'Al Jazeera English', type: 'RSS Feed', url: 'https://www.aljazeera.com/xml/rss.xml', status: appState.data.news.length > 0 ? 'online' : 'offline' },
        { name: 'AP News', type: 'RSS Feed', url: 'https://apnews.com/rss/news', status: appState.data.news.length > 0 ? 'online' : 'offline' },
        { name: 'The Guardian World', type: 'RSS Feed', url: 'https://www.theguardian.com/world/rss', status: appState.data.news.length > 0 ? 'online' : 'offline' },
        { name: 'Euronews English', type: 'RSS Feed', url: 'https://www.euronews.com/rss', status: appState.data.news.length > 0 ? 'online' : 'offline' },
        
        // Regional News
        { name: 'Kyiv Independent', type: 'RSS Feed', url: 'https://kyivindependent.com/rss', status: appState.data.news.length > 0 ? 'online' : 'offline' },
        { name: 'Meduza English', type: 'RSS Feed', url: 'https://meduza.io/rss/en', status: appState.data.news.length > 0 ? 'online' : 'offline' },
        { name: 'Middle East Eye', type: 'RSS Feed', url: 'https://www.middleeasteye.net/feed', status: appState.data.news.length > 0 ? 'online' : 'offline' },
        { name: 'SCMP', type: 'RSS Feed', url: 'https://www.scmp.com/rss/feed/2/news.xml', status: appState.data.news.length > 0 ? 'online' : 'offline' },
        { name: 'AllAfrica', type: 'RSS Feed', url: 'https://allafrica.com/rss/world', status: appState.data.news.length > 0 ? 'online' : 'offline' },
        
        // Defense and Military
        { name: 'Defense News', type: 'RSS Feed', url: 'https://www.defensenews.com/m/rss', status: appState.data.news.length > 0 ? 'online' : 'offline' },
        { name: 'Defense One', type: 'RSS Feed', url: 'https://www.defenseone.com/rss', status: appState.data.news.length > 0 ? 'online' : 'offline' },
        { name: 'The Hacker News', type: 'RSS Feed', url: 'https://feeds.feedburner.com/TheHackersNews', status: appState.data.news.length > 0 ? 'online' : 'offline' },
        
        // Think Tanks
        { name: 'Crisis Group', type: 'RSS Feed', url: 'https://www.crisisgroup.org/rss-0', status: appState.data.news.length > 0 ? 'online' : 'offline' },
        { name: 'Atlantic Council', type: 'RSS Feed', url: 'https://www.atlanticcouncil.org/rss/feed', status: appState.data.news.length > 0 ? 'online' : 'offline' },
        { name: 'War on the Rocks', type: 'RSS Feed', url: 'https://warontherocks.com/feed', status: appState.data.news.length > 0 ? 'online' : 'offline' },
        
        // International Organizations
        { name: 'UN News', type: 'RSS Feed', url: 'https://news.un.org/en/rss-feeds', status: appState.data.news.length > 0 ? 'online' : 'offline' },
        { name: 'NATO News', type: 'RSS Feed', url: 'https://www.nato.int/rss.xml', status: appState.data.news.length > 0 ? 'online' : 'offline' },
        { name: 'Human Rights Watch', type: 'RSS Feed', url: 'https://www.hrw.org/rss/news.rss', status: appState.data.news.length > 0 ? 'online' : 'offline' },
        
        // Data APIs
        { name: 'GDELT Project', type: 'API', url: 'https://api.gdeltproject.org', status: appState.data.events.length > 0 ? 'online' : 'offline' },
        { name: 'CoinGecko', type: 'REST API', url: 'https://api.coingecko.com/api/v3', status: appState.data.crypto.length > 0 ? 'online' : 'offline' },
        { name: 'Frankfurter', type: 'REST API', url: 'https://api.frankfurter.app', status: appState.data.forex.length > 0 ? 'online' : 'offline' }
    ];

    container.innerHTML = sources.map(source => `
        <tr>
            <td><strong>${source.name}</strong></td>
            <td>${source.type}</td>
            <td><code style="font-size: 11px; color: #6b7280;">${source.url}</code></td>
            <td><span class="status-badge ${source.status}">${source.status === 'online' ? 'Online' : 'Offline'}</span></td>
            <td>${formatRelativeTime(appState.lastUpdated)}</td>
            <td><button class="action-btn small" onclick="window.open('${source.url}', '_blank')">Test</button></td>
        </tr>
    `).join('');
}

function renderMapEventsSidebar() {
    const container = document.getElementById('eventsSidebarContent');
    if (!container) return;

    // Get events from the same source as dashboard
    let events = appState.data.events || [];
    
    // Filter out irrelevant sources
    events = filterRelevantEvents(events);
    
    if (events.length === 0) {
        container.innerHTML = '<div style="padding: 1rem; text-align: center; color: #71717a;">Loading events...</div>';
        return;
    }

    const sortedEvents = [...events]
        .sort((a, b) => new Date(b.pubDate || b.timestamps?.published_at) - new Date(a.pubDate || a.timestamps?.published_at))
        .slice(0, 20);

    container.innerHTML = sortedEvents.map(event => `
        <div class="event-item" data-event-id="${event.id}">
            <div class="event-severity-indicator ${getSeverityClass(event.severity || event.metadata?.severity)}"></div>
            <div class="event-content">
                <div class="event-title">${event.title || 'No Title'}</div>
                <div class="event-meta">
                    <span class="event-source">${event.source || 'Unknown'}</span>
                    <span>•</span>
                    <span>${formatRelativeTime(event.pubDate || event.timestamps?.published_at)}</span>
                    ${event.location?.place_name ? `<span>•</span><span>${event.location.place_name}</span>` : ''}
                </div>
            </div>
        </div>
    `).join('');

    container.querySelectorAll('.event-item').forEach(item => {
        item.addEventListener('click', () => {
            const event = appState.data.events.find(e => e.id === item.dataset.eventId);
            if (event) openEventModal(event);
        });
    });
}

function getAircraftClass(type) {
    const classes = {
        fighter: 'critical',
        helicopter: 'high',
        drone: 'medium',
        cargo: 'low',
        unknown: 'info'
    };
    return classes[type] || classes.unknown;
}

function renderSignals() {
    const container = document.getElementById('signalsList');
    if (!container) return;

    let signals = appState.data.signals || FallbackData.signals || [];
    
    // Apply fallback if empty
    if (signals.length === 0) {
        const fallbackSignals = FallbackData.signals || [];
        if (fallbackSignals.length > 0) {
            appState.data.signals = fallbackSignals;
            signals = fallbackSignals;
        }
    }
    
    // If no signals loaded yet, show loading message
    if (signals.length === 0) {
        container.innerHTML = '<div style="padding: 2rem; text-align: center; color: #71717a;">Loading signals...</div>';
        return;
    }
    
    // Apply type filter only (multi-select)
    const selectedTypes = Array.from(signalSelectedTypes);
    const filteredSignals = selectedTypes.length === 0
        ? signals
        : signals.filter(signal => signal.type && signalSelectedTypes.has(signal.type));
    
    // Sort by date posted (newest first)
    filteredSignals.sort((a, b) => new Date(b.pubDate || b.timestamps?.published_at) - new Date(a.pubDate || a.timestamps?.published_at));
    
    if (filteredSignals.length === 0) {
        container.innerHTML = `
            <div style="padding: 2rem; text-align: center; color: #71717a;">
                <p>No signals available for selected types</p>
            </div>
        `;
        return;
    }
    
    container.innerHTML = filteredSignals.slice(0, 20).map(signal => `
        <div class="signal-card">
            <div class="signal-header">
                <span class="signal-type">${signal.type || 'general'}</span>
                <span class="signal-confidence" style="color: ${(signal.confidence || 0) >= 0.7 ? '#10b981' : (signal.confidence || 0) >= 0.5 ? '#f59e0b' : '#ef4444'}">
                    ${((signal.confidence || 0) * 100).toFixed(0)}% confidence
                </span>
            </div>
            <h4 class="signal-title">${signal.title || 'No Title'}</h4>
            <p class="signal-summary">${(signal.summary || '').substring(0, 200)}...</p>
            <div class="signal-meta">
                <span class="signal-source">${signal.source || 'Unknown'}</span>
                <span class="signal-region">${signal.region || 'Global'}</span>
                <span class="signal-time">${formatRelativeTime(signal.pubDate)}</span>
            </div>
            <div class="signal-card-footer">
                <a href="${signal.link || signal.url || ('https://www.google.com/search?q=' + encodeURIComponent(signal.title || 'OSINT signal'))}" target="_blank" rel="noopener" class="read-more-btn">Read More</a>
            </div>
        </div>
    `).join('');
}

function renderPredictions() {
    const container = document.getElementById('predictionsList');
    if (!container) return;

    const predictions = appState.data.predictions || [];
    
    if (predictions.length === 0) {
        container.innerHTML = `
            <div style="padding: 2rem; text-align: center; color: #71717a;">
                <p>Loading predictions...</p>
            </div>
        `;
        return;
    }

    container.innerHTML = `
        <div class="predictions-header-info">
            <div class="predictions-meta">
                <span class="live-badge">
                    <span class="pulse"></span>
                    LIVE CALCULATION
                </span>
                <span class="last-updated">Last calculated: ${formatDateTime(predictions[0]?.lastUpdated || appState.data.predictions?.lastUpdated)}</span>
            </div>
            <p class="methodology-note">
                <strong>Methodology:</strong> ${appState.data.predictions?.methodology || 'Algorithmic trend analysis'}
            </p>
            <p class="data-sources-note">
                <strong>Data Sources:</strong> ${(appState.data.predictions?.dataSources || []).join(' • ')}
            </p>
        </div>
    ` + predictions.map(pred => `
        <div class="prediction-card">
            <div class="prediction-header">
                <span class="prediction-category">${pred.category || 'general'}</span>
                <span class="prediction-indicator ${pred.indicator === 'escalating' ? 'negative' : pred.indicator === 'de-escalating' ? 'positive' : pred.indicator === 'elevated' ? 'warning' : 'neutral'}">
                    ${pred.indicator === 'escalating' ? '↑ Escalating' : pred.indicator === 'de-escalating' ? '↓ De-escalating' : pred.indicator === 'elevated' ? '⚠ Elevated' : '→ Stable'}
                </span>
                <span class="prediction-realtime ${pred.isRealTime ? 'live' : ''}">
                    ${pred.isRealTime ? '● Real-time' : '○ Cached'}
                </span>
            </div>
            <h4 class="prediction-title">${pred.title}</h4>
            
            <div class="prediction-stats">
                <div class="prediction-stat">
                    <div class="prediction-stat-value ${(pred.probability || 0) >= 0.6 ? 'high' : (pred.probability || 0) >= 0.4 ? 'medium' : 'low'}">
                        ${((pred.probability || 0.5) * 100).toFixed(0)}%
                    </div>
                    <div class="prediction-stat-label">Probability</div>
                </div>
                <div class="prediction-stat">
                    <div class="prediction-stat-value">${pred.timeframe || 'N/A'}</div>
                    <div class="prediction-stat-label">Timeframe</div>
                </div>
                <div class="prediction-stat">
                    <div class="prediction-stat-value ${(pred.confidence || 0) >= 0.6 ? 'high' : (pred.confidence || 0) >= 0.4 ? 'medium' : 'low'}">
                        ${((pred.confidence || 0.5) * 100).toFixed(0)}%
                    </div>
                    <div class="prediction-stat-label">Confidence</div>
                </div>
            </div>
            
            ${pred.dataPoints ? `
            <div class="prediction-data-points">
                <h5>Data Points (Calculation Basis)</h5>
                <div class="data-points-grid">
                    <div class="data-point">
                        <span class="data-point-value">${pred.dataPoints.last24h || 0}</span>
                        <span class="data-point-label">Last 24h</span>
                        ${pred.dataPoints.velocity !== undefined ? `
                        <span class="data-point-change ${pred.dataPoints.velocity >= 0 ? 'positive' : 'negative'}">
                            ${pred.dataPoints.velocity >= 0 ? '+' : ''}${pred.dataPoints.velocity}
                        </span>
                        ` : ''}
                    </div>
                    <div class="data-point">
                        <span class="data-point-value">${pred.dataPoints.previous24h || 0}</span>
                        <span class="data-point-label">Previous 24h</span>
                    </div>
                    <div class="data-point">
                        <span class="data-point-value">${pred.dataPoints.weekAgo || 0}</span>
                        <span class="data-point-label">Week Ago</span>
                    </div>
                    <div class="data-point">
                        <span class="data-point-value">${pred.dataPoints.velocity !== undefined ? (pred.dataPoints.velocity > 0 ? '↑ Rising' : pred.dataPoints.velocity < 0 ? '↓ Falling' : '→ Stable') : 'N/A'}</span>
                        <span class="data-point-label">Trend</span>
                    </div>
                </div>
            </div>
            ` : ''}
            
            ${pred.factors ? `
            <div class="prediction-factors">
                <h5>Contributing Factors</h5>
                <ul>
                    ${pred.factors.map(f => `
                        <li>
                            <span class="factor-name">${f.name}</span>
                            <span class="factor-value">${f.value}</span>
                            ${f.change !== undefined ? `<span class="factor-change ${f.change >= 0 ? 'positive' : 'negative'}">${f.change >= 0 ? '+' : ''}${f.change}</span>` : ''}
                        </li>
                    `).join('')}
                </ul>
            </div>
            ` : ''}
            
            ${pred.methodology ? `
            <div class="prediction-methodology">
                <small>${pred.methodology}</small>
            </div>
            ` : ''}
        </div>
    `).join('');
    
    // Add disclaimer at the bottom
    container.innerHTML += `
        <div class="predictions-disclaimer">
            <p><strong>Disclaimer:</strong> These predictions are algorithmic assessments based on available OSINT data and should not be used as the sole basis for decision-making. ${appState.data.predictions?.disclaimer || ''}</p>
        </div>
    `;
}

// Modal Functions
function openEventModal(event) {
    appState.selectedEvent = event;

    const modal = document.getElementById('eventModal');
    if (!modal) return;

    const severityEl = document.getElementById('modalSeverity');
    const typeEl = document.getElementById('modalType');
    const titleEl = document.getElementById('modalTitle');
    const dateEl = document.getElementById('modalDate');
    const locationEl = document.getElementById('modalLocation');
    const summaryEl = document.getElementById('modalSummary');
    const sourceLinkEl = document.getElementById('modalSourceLink');
    const tagsContainer = document.getElementById('modalTags');

    const severity = event.severity || event.metadata?.severity || 'info';
    const type = event.type || event.metadata?.type || 'geopolitical';
    const pubDate = event.pubDate || event.timestamps?.published_at;
    const location = event.location;
    const url = event.url || event.link;
    const source = event.source;
    const title = event.title;
    const summary = event.summary;

    if (severityEl) {
        severityEl.textContent = severity.toUpperCase();
        severityEl.className = `modal-severity ${getSeverityClass(severity)}`;
    }
    if (typeEl) typeEl.textContent = (type || 'geopolitical').toUpperCase();
    if (titleEl) titleEl.textContent = title || 'No Title';
    if (dateEl && pubDate) dateEl.textContent = formatDateTime(pubDate);
    if (locationEl) locationEl.textContent = location?.place_name || 'Global';
    if (summaryEl) summaryEl.textContent = summary || 'No summary available';
    if (sourceLinkEl) {
        sourceLinkEl.href = url || '#';
        sourceLinkEl.textContent = source || 'Source';
    }

    modal.classList.add('active');
}

function closeEventModal() {
    const modal = document.getElementById('eventModal');
    if (modal) {
        modal.classList.remove('active');
    }
    appState.selectedEvent = null;
}

// Toast Notifications
function showToast(title, message, type = 'info') {
    const container = document.getElementById('toastContainer');
    if (!container) return;

    const toast = document.createElement('div');
    toast.className = `toast ${type}`;

    const icons = {
        success: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>',
        error: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>',
        warning: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>',
        info: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>'
    };

    toast.innerHTML = `
        <span class="toast-icon">${icons[type] || icons.info}</span>
        <div class="toast-content">
            <div class="toast-title">${title}</div>
            <div class="toast-message">${message}</div>
        </div>
        <button class="toast-close" onclick="this.parentElement.remove()">×</button>
    `;

    container.appendChild(toast);

    setTimeout(() => {
        if (toast.parentElement) {
            toast.style.animation = 'slideIn 0.3s ease reverse';
            setTimeout(() => toast.remove(), 300);
        }
    }, 5000);
}

// Page Navigation
function navigateToPage(pageName) {
    document.querySelectorAll('.nav-item').forEach(item => {
        item.classList.toggle('active', item.dataset.page === pageName);
    });

    document.querySelectorAll('.page-view').forEach(view => {
        view.classList.toggle('active', view.id === `${pageName}-view`);
    });

    const titles = {
        dashboard: 'Dashboard',
        map: 'Map & Events',
        feeds: 'News Feeds',
        signals: 'OSINT Signals',
        markets: 'Market Data',
        predictions: 'Predictions',
        sources: 'Data Sources',
        about: 'About',
        contact: 'Contact'
    };
    
    const pageTitleEl = document.getElementById('pageTitle');
    if (pageTitleEl) {
        pageTitleEl.textContent = titles[pageName] || pageName;
    }
    
    updateLastUpdatedTime();
    appState.currentPage = pageName;
    
    // Auto-collapse sidebar on mobile after navigation
    const sidebar = document.getElementById('sidebar');
    if (sidebar && window.innerWidth < 1024) {
        sidebar.classList.remove('open');
    }

    // Initialize map and start activity tracking when navigating to map page
    if (pageName === 'map' && !appState.map) {
        setTimeout(() => {
            appState.map = initializeMap('fullMap');
            if (appState.map) {
                appState.map.on('load', () => {
                    // Hide loading indicator
                    const mapContainer = document.getElementById('fullMap');
                    if (mapContainer) mapContainer.classList.add('loaded');
                    // Start military activity tracking on full map
                    MilitaryTracker.startTracking(appState.map);
                });
                appState.map.on('error', (e) => {
                    console.error('Full map error:', e);
                    const mapContainer = document.getElementById('fullMap');
                    if (mapContainer) mapContainer.classList.remove('loaded');
                });
            } else {
                // Map initialization failed
                const mapContainer = document.getElementById('fullMap');
                if (mapContainer) mapContainer.classList.remove('loaded');
            }
        }, 100);
    }
}

function updateLastUpdatedTime() {
    const lastUpdatedEl = document.getElementById('lastUpdated');
    if (lastUpdatedEl && appState.lastUpdated) {
        lastUpdatedEl.textContent = formatRelativeTime(appState.lastUpdated);
    }
}

// Event Handlers
function setupEventListeners() {
    document.querySelectorAll('.nav-item').forEach(item => {
        item.addEventListener('click', (e) => {
            e.preventDefault();
            navigateToPage(item.dataset.page);
        });
    });

    document.querySelectorAll('.view-all-link').forEach(link => {
        link.addEventListener('click', (e) => {
            e.preventDefault();
            navigateToPage(link.dataset.page);
        });
    });

    const sidebarToggle = document.getElementById('sidebarToggle');
    const sidebar = document.getElementById('sidebar');
    if (sidebarToggle && sidebar) {
        sidebarToggle.addEventListener('click', () => {
            sidebar.classList.toggle('open');
        });
    }

    
    
    // Handle dashboard fullscreen button
    document.querySelectorAll('.action-btn[data-action="fullscreen"]').forEach(btn => {
        btn.addEventListener('click', () => {
            const mapCard = btn.closest('.dashboard-card');
            if (mapCard) {
                const mapContainer = mapCard.querySelector('.map-container');
                if (mapContainer) {
                    if (document.fullscreenElement) {
                        document.exitFullscreen();
                    } else {
                        mapContainer.requestFullscreen();
                    }
                }
            }
        });
    });
    
    // Handle map fullscreen button (Map & Events page)
    const mapFullscreenBtn = document.getElementById('mapFullscreenBtn');
    if (mapFullscreenBtn) {
        mapFullscreenBtn.addEventListener('click', () => {
            const fullMap = document.getElementById('fullMap');
            if (fullMap) {
                if (document.fullscreenElement) {
                    document.exitFullscreen();
                } else {
                    fullMap.requestFullscreen();
                }
            }
        });
    }
    
const modalClose = document.getElementById('modalClose');
    const modal = document.getElementById('eventModal');
    if (modalClose && modal) {
        modalClose.addEventListener('click', closeEventModal);
        modal.addEventListener('click', (e) => {
            if (e.target === modal) closeEventModal();
        });
    }

    const refreshBtn = document.getElementById('refreshBtn');
    if (refreshBtn) {
        refreshBtn.addEventListener('click', () => {
            fetchAllData();
        });
    }
}

// Loading State
function showLoading() {
    const overlay = document.getElementById('loadingOverlay');
    if (overlay) {
        overlay.classList.add('active');
    }
}

function hideLoading() {
    const overlay = document.getElementById('loadingOverlay');
    if (overlay) {
        overlay.classList.remove('active');
    }
}

// Initialization
async function initializeApp() {
    showLoading();

    try {
        setupEventListeners();
        await fetchAllData();

        // Initialize dashboard map
        setTimeout(() => {
            const dashboardMap = initializeMap('dashboardMap');
            if (dashboardMap) {
                dashboardMap.on('load', () => {
                    // Hide loading indicator
                    const mapContainer = document.getElementById('dashboardMap');
                    if (mapContainer) mapContainer.classList.add('loaded');
                    // Start military activity tracking
                    MilitaryTracker.startTracking(dashboardMap);
                });
                dashboardMap.on('error', (e) => {
                    console.error('Dashboard map error:', e);
                    const mapContainer = document.getElementById('dashboardMap');
                    if (mapContainer) mapContainer.classList.remove('loaded');
                });
            } else {
                // Map initialization failed
                const mapContainer = document.getElementById('dashboardMap');
                if (mapContainer) mapContainer.classList.remove('loaded');
            }
        }, 100);

        // Set up auto-refresh every 10 minutes
        appState.refreshInterval = setInterval(() => {
            fetchAllData();
        }, 10 * 60 * 1000);

        showToast('Welcome to !ntellibot', 'Live data loaded successfully', 'success');
    } catch (error) {
        console.error('Initialization error:', error);
        showToast('Error', 'Failed to initialize dashboard', 'error');
    } finally {
        hideLoading();
    }
}

// Start the application
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeApp);
} else {
    initializeApp();
}
